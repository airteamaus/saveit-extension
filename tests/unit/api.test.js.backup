import { describe, it, expect, vi, beforeEach } from 'vitest';
import { MOCK_DATA } from '../../src/mock-data.js';

// Mock API module
const createMockAPI = () => ({
  isExtension: false,
  CACHE_KEY: 'savedPages_cache',
  CACHE_MAX_AGE_MS: 5 * 60 * 1000,

  async parseErrorResponse(response) {
    try {
      const data = await response.json();
      return data.error || data.message || `HTTP ${response.status}`;
    } catch {
      return response.statusText || `HTTP ${response.status}`;
    }
  },

  async getSavedPages(options = {}) {
    if (this.isExtension) {
      const response = await fetch(`${CONFIG.cloudFunctionUrl}?limit=50`);
      if (!response.ok) {
        const errorMessage = await this.parseErrorResponse(response);
        throw new Error(errorMessage);
      }
      return await response.json();
    }
    return this.filterMockData(MOCK_DATA, options);
  },

  filterMockData(data, options) {
    let filtered = [...data];

    if (options.search) {
      const query = options.search.toLowerCase();
      filtered = filtered.filter(item =>
        item.title?.toLowerCase().includes(query) ||
        item.url?.toLowerCase().includes(query)
      );
    }

    if (options.sort === 'newest') {
      filtered.sort((a, b) => new Date(b.saved_at || b.timestamp) - new Date(a.saved_at || a.timestamp));
    }

    return filtered;
  }
});

describe('API', () => {
  let API;

  beforeEach(() => {
    API = createMockAPI();
  });

  describe('isExtension detection', () => {
    it('should detect standalone mode', () => {
      expect(API.isExtension).toBe(false);
    });
  });

  describe('getSavedPages', () => {
    it('should return mock data in standalone mode', async () => {
      API.isExtension = false;
      const pages = await API.getSavedPages();

      expect(Array.isArray(pages)).toBe(true);
      expect(pages.length).toBeGreaterThan(0);
      expect(pages[0]).toHaveProperty('id');
      expect(pages[0]).toHaveProperty('title');
    });

    it('should filter by search query', async () => {
      API.isExtension = false;
      const pages = await API.getSavedPages({ search: 'Himalayas' });

      expect(pages.length).toBeGreaterThan(0);
      expect(pages[0].title).toContain('Himalayas');
    });

    it('should return empty array for non-matching search', async () => {
      API.isExtension = false;
      const pages = await API.getSavedPages({ search: 'xyznonexistent123' });

      expect(pages).toEqual([]);
    });

    it('should sort by newest first', async () => {
      API.isExtension = false;
      const pages = await API.getSavedPages({ sort: 'newest' });

      expect(pages.length).toBeGreaterThan(1);
      const firstDate = new Date(pages[0].saved_at || pages[0].timestamp);
      const secondDate = new Date(pages[1].saved_at || pages[1].timestamp);
      expect(firstDate >= secondDate).toBe(true);
    });
  });

  describe('parseErrorResponse', () => {
    it('should extract error from JSON response', async () => {
      const mockResponse = {
        status: 400,
        json: vi.fn().mockResolvedValue({ error: 'Bad Request Error' })
      };

      const error = await API.parseErrorResponse(mockResponse);
      expect(error).toBe('Bad Request Error');
    });

    it('should use message field if no error field', async () => {
      const mockResponse = {
        status: 400,
        json: vi.fn().mockResolvedValue({ message: 'Validation failed' })
      };

      const error = await API.parseErrorResponse(mockResponse);
      expect(error).toBe('Validation failed');
    });

    it('should fallback to status code if JSON parsing fails', async () => {
      const mockResponse = {
        status: 500,
        statusText: 'Internal Server Error',
        json: vi.fn().mockRejectedValue(new Error('Not JSON'))
      };

      const error = await API.parseErrorResponse(mockResponse);
      expect(error).toBe('Internal Server Error');
    });

    it('should use HTTP status as last resort', async () => {
      const mockResponse = {
        status: 404,
        statusText: '',
        json: vi.fn().mockRejectedValue(new Error('Not JSON'))
      };

      const error = await API.parseErrorResponse(mockResponse);
      expect(error).toBe('HTTP 404');
    });
  });

  describe('filterMockData', () => {
    it('should support both timestamp and saved_at fields', () => {
      const dataWithBothFields = [
        { id: '1', title: 'Page 1', timestamp: '2024-01-20T10:00:00Z' },
        { id: '2', title: 'Page 2', saved_at: '2024-01-21T10:00:00Z' },
        { id: '3', title: 'Page 3', saved_at: '2024-01-19T10:00:00Z', timestamp: '2024-01-19T10:00:00Z' }
      ];

      const sorted = API.filterMockData(dataWithBothFields, { sort: 'newest' });

      expect(sorted[0].id).toBe('2'); // newest saved_at
      expect(sorted[1].id).toBe('1'); // timestamp
      expect(sorted[2].id).toBe('3'); // oldest
    });
  });
});
